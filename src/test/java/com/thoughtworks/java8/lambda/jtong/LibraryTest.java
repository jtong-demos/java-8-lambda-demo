package com.thoughtworks.java8.lambda.jtong;/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.io.PrintStream;
import java.util.function.*;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;


@DisplayName("java 8 lambda demo suite")
class LibraryTest {

    @BeforeAll
    static void initTestEnv() {
    }

    @BeforeEach
    void initEveryMethod() {
    }

    @Test
    @DisplayName("Predicate accept 1 argument, return boolean")
    void testPredicate() {
        Predicate<Player> playerIsAlive = p -> p.getHp() > 0;
        Player zhangsan = new Player("张三", 100, 10);

        assertThat(playerIsAlive.test(zhangsan), is(true));
        assertThat(playerIsAlive.negate().test(zhangsan), is(false));
    }

    @Test
    @DisplayName("Predicate can only 'and' Predicate")
    void testPredicateAnd() {
        Predicate<Player> playerIsAlive = p -> p.getHp() > 0;
        Predicate<Player> playerHasName = p -> p.getName() != null;
        Player zhangsan = new Player("张三", 100, 10);

        Player johnDoe = new Player(null, 100, 5);

        assertThat(playerIsAlive.and(playerHasName).test(zhangsan), is(true));
        assertThat(playerIsAlive.and(playerHasName).test(johnDoe), is(false));
    }

    @Test
    @DisplayName("BiPredicate accept 2 arguments, return boolean")
    void testBiPredicate() {
        BiPredicate<Player, Player> AP_of_playerA_bigger_than_playerB = (playerA, playerB) -> playerA.getAp() > playerB.getAp();
        Player zhangsan = new Player("张三", 100, 10);
        Player lisi = new Player("李四", 100, 8);

        assertThat(AP_of_playerA_bigger_than_playerB.test(zhangsan, lisi), is(true));
    }


    @Test
    @DisplayName("Function need two generic params, 1 for argument, 1 for result")
    void testFunction() {
        Function<Player, String> introduceMySelf = (player) ->  "姓名："+player.getName() +"，HP：" + player.getHp() ;
        Player zhangsan = new Player("张三", 100, 10);

        assertThat(introduceMySelf.apply(zhangsan), is("姓名：张三，HP：100"));
    }

    @Test
    @DisplayName("Function identity do nothing")
    void testFunction_identity() {
        Function<Player,Player> doNothing = Function.identity() ;
        Player zhangsan = new Player("张三", 100, 10);

        assertThat(doNothing.apply(zhangsan) == zhangsan, is(true));
    }


    @Test
    @DisplayName("Function compose combine before, of course only combine Function")
    void testFunction_compose() {
        Function<Integer,Integer> increase = i -> i+1;
        Function<Integer, Integer> doubleIt = i -> i*2;


        assertThat(increase.compose(doubleIt).apply(1), is(3));//(1*2)+1
    }


    @Test
    @DisplayName("Function andThen combine after")
    void testFunction_andThen() {
        Function<Integer,Integer> increase = i -> i+1;
        Function<Integer, Integer> doubleIt = i -> i*2;


        assertThat(increase.andThen(doubleIt).apply(1), is(4));//(1+1)*2
    }


    @Test
    @DisplayName("BiFunction need 3 generic params, 2 for argument, 1 for result")
    void testBiFunction() {
        BiFunction<String, String, String> love = (personA, personB) ->  personA +"爱上了" + personB;

        assertThat(love.apply("阿珍", "阿强"), is("阿珍爱上了阿强"));
    }


    @Test
    @DisplayName("Consumber return northing, but it really called")
    void testConsumner() {
        final PrintStream mockStream = mock(PrintStream.class);
        Consumer<Player> sayHi = (player) ->  {
            mockStream.println("Hi, " + player.getName());
        };
        Player zhangsan = new Player("张三", 100, 10);
        sayHi.accept(zhangsan);

        verify(mockStream).println("Hi, 张三");
    }

}